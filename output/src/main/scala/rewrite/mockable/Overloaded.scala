package rewrite.mockable

import zio._
import zio.mock.Mock

object Overloaded {
  type OverloadedPureDefsModule = OverloadedPureDefsModule.Service
  object OverloadedPureDefsModule {
    trait Service {
      def overloaded(n: Int): IO[String, String]
      def overloaded(n: Long): IO[String, String]
    }
  }

  type OverloadedImpureDefsModule = OverloadedImpureDefsModule.Service
  object OverloadedImpureDefsModule {
    trait Service {
      def overloaded(n: Int): String
      def overloaded(n: Long): String
    }
  }
}
import Overloaded._


object OverloadedPureDefsMocks extends Mock[OverloadedPureDefsModule] {
  // format: off
  // Generated by ZIO Mockable CodeGen Scalafix Rule
  object Overloaded {
    case object _0 extends Effect[Int, String, String]
    case object _1 extends Effect[Long, String, String]
  }
  override val compose: URLayer[mock.Proxy, OverloadedPureDefsModule] = ZLayer.fromZIO[mock.Proxy, Nothing, OverloadedPureDefsModule](
    ZIO.service[mock.Proxy].flatMap { proxy =>
      withRuntime[mock.Proxy, OverloadedPureDefsModule] { rt =>
        class MockImpl extends OverloadedPureDefsModule {
          final override def overloaded(n: Int): ZIO[Any, String, String] = proxy(Overloaded._0, n)
          final override def overloaded(n: Long): ZIO[Any, String, String] = proxy(Overloaded._1, n)
        }
        ZIO.succeed(new MockImpl())
  }})
  // format: on
}


object OverloadedImpureDefsMocks extends Mock[OverloadedImpureDefsModule] {
  // format: off
  // Generated by ZIO Mockable CodeGen Scalafix Rule
  object Overloaded {
    case object _0 extends Method[Int, Throwable, String]
    case object _1 extends Method[Long, Throwable, String]
  }
  override val compose: URLayer[mock.Proxy, OverloadedImpureDefsModule] = ZLayer.fromZIO[mock.Proxy, Nothing, OverloadedImpureDefsModule](
    ZIO.service[mock.Proxy].flatMap { proxy =>
      withRuntime[mock.Proxy, OverloadedImpureDefsModule] { rt =>
        class MockImpl extends OverloadedImpureDefsModule {
          final override def overloaded(n: Int): String = Unsafe.unsafe { case given Unsafe => rt.unsafe.run(proxy(Overloaded._0, n)).getOrThrow() }
          final override def overloaded(n: Long): String = Unsafe.unsafe { case given Unsafe => rt.unsafe.run(proxy(Overloaded._1, n)).getOrThrow() }
        }
        ZIO.succeed(new MockImpl())
  }})
  // format: on
}

object OverloadedTest {
  import Overloaded._
  implicitly[OverloadedPureDefsMocks.type <:< Mock[OverloadedPureDefsModule]]
  implicitly[OverloadedPureDefsMocks.Overloaded._0.type <:< OverloadedPureDefsMocks.Effect[Int, String, String]]
  implicitly[OverloadedPureDefsMocks.Overloaded._1.type <:< OverloadedPureDefsMocks.Effect[Long, String, String]]

  implicitly[OverloadedImpureDefsMocks.type <:< Mock[OverloadedImpureDefsModule]]
  implicitly[OverloadedImpureDefsMocks.Overloaded._0.type <:< OverloadedImpureDefsMocks.Method[Int, Throwable, String]]
  implicitly[OverloadedImpureDefsMocks.Overloaded._1.type <:< OverloadedImpureDefsMocks.Method[Long, Throwable, String]]
}
